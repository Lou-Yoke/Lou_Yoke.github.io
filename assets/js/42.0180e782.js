(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{522:function(a,t,s){"use strict";s.r(t);var v=s(4),_=Object(v.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"即使被拖库也可以保证密码不泄漏"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#即使被拖库也可以保证密码不泄漏"}},[a._v("#")]),a._v(" 即使被拖库也可以保证密码不泄漏")]),a._v(" "),s("p",[a._v("首先，我们明确一下安全加密方案的终极目标："),s("br"),a._v(" "),s("strong",[a._v("即使在数据被拖库，代码被泄漏，请求被劫持的情况下，也能保证用户的密码不被泄漏。")]),s("br"),a._v("\n说具体一些，我们理想中的绝对安全的系统大概是这样的：")]),a._v(" "),s("ol",[s("li",[a._v("首先保障数据很难被拖库。")]),a._v(" "),s("li",[a._v("即使数据被拖库，攻击者也无法从中破解出用户的密码。")]),a._v(" "),s("li",[a._v("即使数据被拖库，攻击者也无法伪造登陆请求通过验证。")]),a._v(" "),s("li",[a._v("即使数据被拖库，攻击者劫持了用户的请求数据，也无法破解出用户的密码。")])]),a._v(" "),s("p",[a._v("如何保障数据不被拖库，这里就不展开讲了。首先说一说密码加密。现在应该很少系统会直接保存用户密码了，至少也是会计算密码的MD5后保存。md5这种不可逆的加密方法理论上很安全了，但是随着彩虹表的出现，使得大量长度不够的密码可以直接从彩虹表里反推出来。"),s("br"),a._v("\n所以，只对密码进行md5加密肯定是不够的。聪明的程序员相想出了个办法，即使用户的密码很短，只要我在他的短密码后面加上一段很长的字符串，再计算md5，那反推出原始密码就变得非常困难了。加上的这段长字符串，我们称为盐（salt），通过这种方式加密的结果，我们称为"),s("code",[a._v("加盐Hash")]),a._v(".比如：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("md5(md5(password)+salt)  \n")])])]),s("p",[a._v("常用的哈希函数中，SHA-256、SHA-512会比md5更安全，更难破解，出于更高安全性的考虑，我的这个方案中，会使用SHA-512代替md5。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("SHA512(SHA512(password)+salt)  \n")])])]),s("p",[a._v("通过上面的加盐哈希运算，即使攻击者拿到了最终结果，也很难反推出原始的密码。不能反推，但可以正着推，假设攻击者将salt值也拿到了，那么他可以枚举遍历所有6位数的简单密码，加盐哈希，计算出一个结果对照表，从而破解出简单的密码。这就是通常所说的暴力破解。"),s("br"),a._v("\n为了应对暴力破解，我试用了加盐的"),s("code",[a._v("慢哈希")]),a._v("。慢哈希是指执行这个哈希函数非常慢，这样暴力破解需要枚举遍历所有可能结果时，就需要花上非常长的时间。比如：bcrypt就是这样一个慢哈希函数：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("bcrypt(SHA512(password),salt,cost)  \n")])])]),s("p",[a._v("通过调用"),s("code",[a._v("cost")]),a._v("参数，可以调整该函数慢到什么程度。假设让bcrypt计算一次需要0.5秒，遍历6位的简单密码，需要的时间位:((26*2+10)^6)/2秒，约900年。"),s("br"),a._v("\n好了，有上面的基础，来看看我的最终解决方案："),s("br"),a._v(" "),s("img",{attrs:{src:"http://image.coderzh.com/password_security.jpg",alt:"解决方案"}}),s("br"),a._v("\n上图里有很多细节，我分阶段来讲："),s("br"),a._v(" "),s("strong",[a._v("1. 协商密钥")]),s("br"),a._v("\n基于非对称加密的密钥协商算法，可以在通讯内容完全被公开的情况下，双方协商出一个只有双方才知道的密钥，然后使用该密钥进行对称加密传输数据。比如图中所用的ECDH密钥协商。"),s("br"),a._v(" "),s("strong",[a._v("2. 请求Salt")]),s("br"),a._v("\n双方协商出一个密钥SharedKey之后，就可以使用SharedKey作为AES对称加密的密钥进行通信，客户端传给服务端自己的公钥A，以及加密了的用户ID（uid）。服务端从数据库汇总查找到该uid对于的Salt1和Salt2，然后再加密返回给客户端。"),s("br"),a._v("\n注意，服务端保存的Salt1和Salt2最好和用户数据分开存储，存到其他服务器的数据库里，这样即使被SQL注入，想要获得Salt和Salt2也会非常困难的。"),s("br"),a._v(" "),s("strong",[a._v("3. 验证密码")]),s("br"),a._v("\n这是最重要的一步了。客户端拿到Salt1和Salt2之后，可以计算出两个加盐哈希：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("SaltHash1 = bcrypt(SHA512(password),uid+salt1,10)  \nSlatHash2 = SHA512(SaltHash1+uid+salt2)  \n")])])]),s("p",[a._v("使用SaltHash2作为AES密钥，加密包括uid,time,SaltHash1,RandKey等内容传输给服务端：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("Ticket=AES(SaltHash2,uid+time+saltHash1+RandKey)  \nAES(SharedKey,Ticket)  \n")])])]),s("p",[a._v("服务端使用SharedKey解密出TIcket之后，再从数据库中找到该uid对应的SaltHash2，解密Ticket，得到SaltHash1，使用SaltHash1重新计算SaltHash2看是否和数据库汇总的SaltHash2一致，从而验证密码是否正确。"),s("br"),a._v("\n校验两个哈希值是否相等时，使用我时间恒定的比较函数，防止试探性攻击。"),s("br"),a._v("\ntime用于记录数据包发送的时间，用来防止录制回放攻击。"),s("br"),a._v(" "),s("strong",[a._v("4. 加密传输")]),s("br"),a._v("\n密码验证通过后，服务端生成一个随机的临时密钥TempKey(使用安全的随机函数)，并使用RandKey作为密钥，传输给客户端。之后双方的数据交互都通过TempKey作为AES密钥进行加密。")]),a._v(" "),s("h2",{attrs:{id:"假设被拖库了"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#假设被拖库了"}},[a._v("#")]),a._v(" 假设被拖库了")]),a._v(" "),s("p",[a._v("以上就是整个加密传输、存储的全过程。我们来假设几种攻击场景：")]),a._v(" "),s("ol",[s("li",[s("p",[a._v("假设数据被拖库了，密码会泄漏吗？"),s("br"),a._v("\n数据库中的Salt1，Salt2，SaltHash2暴漏了，想从SaltHash2直接反解出原始密码几乎是不可能的事情。")])]),a._v(" "),s("li",[s("p",[a._v("假设数据被拖库了，攻击者能不能伪造登陆请求通过验证？"),s("br"),a._v("\n攻击者在生成Ticket时，需要SaltHash1，但由于并不知道密码，所以无法计算出SaltHash1，又无法从SaltHash2反推出SaltHash1，所以无法伪造登陆请求通过验证。")])]),a._v(" "),s("li",[s("p",[a._v("假设数据被拖库了，攻击者使用中间人攻击，劫持了用户的请求，密码会被泄漏吗？"),s("br"),a._v("\n中间人拥有真实服务器所有的数据，仿冒了真是的server,因此，他可以解密出TIcket中的SaltHash1，"),s("code",[a._v("但是SaltHash1是无法解密出原始密码的，所以密码也不会被泄漏。")]),s("br"),a._v("\n但是，中间人攻击可以获取到最后的TempKey,从而能监听后续的所有通信过程。这是很难解决的为题，因为在服务端所有东西都暴漏的情况下，中间人假设可以接触用户数据，仿冒真是server,是很难和真是的server区分开的。解决的方法也许只有防止被中间人攻击，保证server公钥在库护短不被篡改。"),s("br"),a._v("\n建设攻击已经进展到了这样的成都，还有补救吗？有。由于攻击者只能坚听用户的登陆过程，并不知道真实的密码。所以，只需要在服务端对Salt2进行升级，即可生成新的SaltHash2，从而让攻击者所有攻击失效。"),s("br"),a._v("\n具体是这样的：用户正常登陆，服务毒案验证通过后，生成洗的Salt2，然后根据传过来的SaltHash1重新就是那了SaltHash2存入数据库，下次用户再次登陆时，获取到的是新的Salt2，密码没有变，同样能登陆，攻击者之前拖库的那份数据也失失效了。")])])]),a._v(" "),s("h2",{attrs:{id:"q-a"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#q-a"}},[a._v("#")]),a._v(" Q&A")]),a._v(" "),s("ol",[s("li",[a._v("使用 bcrypt 慢哈希函数，服务端应对大量的用户登录请求，性能承受的了吗？")])]),a._v(" "),s("p",[a._v("该方案中，细心一点会注意到， bcrypt 只是在客户端进行运算的，服务端是直接拿到客户端运算好的结果（ SaltHash1 ）后 SHA-512\n计算结果进行验证的。所以，把性能压力分摊到了各个客户端。")]),a._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[a._v("为什么要使用两个 Salt 值？")])]),a._v(" "),s("p",[a._v("使用两个 Salt 值，是为了防止拖库后，劫持了用户请求后将密码破解出来。只有拥有密码的用户，才能用第一个 Salt 值计算出 SaltHash1\n，并且不能反推回原始密码。第二个 Salt 值可以加大被拖库后直接解密出 SaltHash1 的难度。")]),a._v(" "),s("ol",{attrs:{start:"3"}},[s("li",[a._v("为什么要动态请求 Salt1 和 Salt2 ？")])]),a._v(" "),s("p",[a._v("Salt 值直接写在客户端肯定不好，而且写死了要修改还得升级客户端。动态请求 Salt\n值，还可以实现不升级客户端的情况下，对密码进行动态升级：服务端可定期更换 Salt2 ，重新计算 SaltHash2\n，让攻击者即使拖了一次数据也很快处于失效状态。")]),a._v(" "),s("ol",{attrs:{start:"4"}},[s("li",[a._v("数据库都已经全被拖走了，密码不泄露还有什么意义呢？")])]),a._v(" "),s("p",[a._v("其实是有意义的，正如刚刚提到的升级 Salt2\n的补救方案，用户可以在完全不知情的情况下，不需要修改密码就升级了账号体系。同时，保护好用户的密码，不被攻击者拿去撞别家网站的库，也是一份责任。")]),a._v(" "),s("ol",{attrs:{start:"5"}},[s("li",[a._v("“应该从源头上禁止用户使用简单密码”")])]),a._v(" "),s("p",[a._v("回复：非常同意！")]),a._v(" "),s("ol",{attrs:{start:"6"}},[s("li",[a._v("“获取 salt 并不需要啥验证，那么还有必要分开存储么，脱裤者直接根据uid调一遍接口不就拿到了？相当于就是公开的吧？”")])]),a._v(" "),s("p",[a._v("回复：确实是这样。salt 相当于公开的了，没有必要分开存储了。如果你有更好的方法，请告诉我。")]),a._v(" "),s("ol",{attrs:{start:"7"}},[s("li",[a._v("“使用 HTTPS(SSL/TLS) 来保障传输的安全是不是就可以了？”")])]),a._v(" "),s("p",[a._v("回复：理论上是足够了，而且推荐使用。 如果你的项目安全级别非常高，本着不信任绝对安全的角度可考虑再一层加固。")]),a._v(" "),s("ol",{attrs:{start:"8"}},[s("li",[a._v("“salt 使用密码学安全的随机数生成就够了，不需要使用 uid 。”")])]),a._v(" "),s("p",[a._v("回复：同意，确实不是很必要。")]),a._v(" "),s("ol",{attrs:{start:"9"}},[s("li",[a._v("“服务器性能够强劲，bcrypt 放在服务端执行也没什么问题。”")])]),a._v(" "),s("p",[a._v("回复：通过调整 bcrypt 参数让服务端执行在可接受的时间范围内确实可以。但是把这种耗时的操作放到客户端去做不是更好吗？")]),a._v(" "),s("ol",{attrs:{start:"10"}},[s("li",[a._v("“不知攻焉知防，还是使用现有的算法和协议比较好，不要自己发明。即使自己发明，也需要经过实践的检验不断迭代才行。”")])]),a._v(" "),s("p",[a._v("回复：首先，文中用到的都是现有的成熟算法，如 bcrypt，SHA-512， AES ，包括\nECDH，并没有重新发明什么。文章重点是对密码的两次加盐哈希以及密码的验证方式。当然，方案需要在实践中不断迭代优化，我也是不能同意再多。")])])}),[],!1,null,null,null);t.default=_.exports}}]);