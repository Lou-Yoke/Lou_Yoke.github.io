(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{529:function(t,v,_){"use strict";_.r(v);var r=_(4),a=Object(r.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"服务器端限流保护"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#服务器端限流保护"}},[t._v("#")]),t._v(" 服务器端限流保护")]),t._v(" "),_("p",[t._v("服务器端在收到客户端过多的请求时，往往会因为过高的cpu或者内存消耗而宕掉。这就有一个原则是服务端要能自我保护，\n"),_("strong",[t._v("宁可提供受损的服务，也不能不提供服务。")]),t._v(" 在开发高并发系统时有三把利器来保护系统： "),_("strong",[t._v("缓存、降级和限流")]),t._v(" 。"),_("br"),t._v(" "),_("strong",[t._v("缓存")]),t._v("\n的目的是提高系统访问速度和增大系统能处理的容量。项目中有很多地方用到了缓存。其中一个场景就是，客户端会长传一个信令表明身份，而这个信令有专门的服务来维护，我们就需要拿着这个信令调用那个服务的http接口来验证，当并发较多时，http请求就有可能拥堵。考虑到这个信令的存活时间较长，就可以在redis中做一下缓存，定期清理。这样就减少了http请求次数。")]),t._v(" "),_("p",[_("strong",[t._v("降级")]),t._v("\n是当服务出问题或者影响到核心流程的性能时，需要暂时屏蔽掉一些服务，待高峰或者问题解决后再打开。这个方法基本上每一个服务都用到了，高峰时或者cpu、内存占用较高时，减少日志记录、主动拒绝一些请求等。")]),t._v(" "),_("p",[t._v("而有些场景并不能用缓存和降级来解决，比如稀缺资源（秒杀、抢购）、写服务（如评论、下单）、频繁的复杂查询（评论的最后几页），因此需有一种手段来限制这些场景的并发/请求量，即\n"),_("strong",[t._v("限流")]),t._v(" 。")]),t._v(" "),_("p",[_("strong",[t._v("限流")]),t._v(" 的目的是通过对并发访问/请求进行限制或者一个时间窗口内的请求进行限流来保护系统，一旦达到限制速率则可以拒绝服务或者排队等待。")]),t._v(" "),_("h2",{attrs:{id:"令牌桶算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#令牌桶算法"}},[t._v("#")]),t._v(" 令牌桶算法")]),t._v(" "),_("p",[t._v("令牌桶算法是一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌。简单描述如下：")]),t._v(" "),_("ul",[_("li",[t._v("假设限制2r/s,则按照500ms的固定速率往桶中添加令牌；")]),t._v(" "),_("li",[t._v("同种最多存放b个令牌，当桶满时，新添加的令牌被丢弃或拒绝；")]),t._v(" "),_("li",[t._v("当n 个请求到来时，从同种删除n个令牌，接着处理请求；")]),t._v(" "),_("li",[t._v("如果桶中的令牌不足n个，则拒绝后面的部分。"),_("br"),t._v(" "),_("img",{attrs:{src:"https://images2015.cnblogs.com/blog/455275/201609/455275-20160913123114461-431665736.png",alt:"令牌桶算法"}})])]),t._v(" "),_("h2",{attrs:{id:"漏桶算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#漏桶算法"}},[t._v("#")]),t._v(" 漏桶算法")]),t._v(" "),_("p",[t._v("漏桶作为计量工具时，可以用于流量整形和流量控制。简单描述如下：")]),t._v(" "),_("ul",[_("li",[t._v("一个固定容量的漏桶，按照常量固定速率流出水滴；")]),t._v(" "),_("li",[t._v("如果桶时空的，则不需要流出水滴；")]),t._v(" "),_("li",[t._v("可以以任意的速率流入水滴；")]),t._v(" "),_("li",[t._v("如果流入水滴超出了桶的容量，则流入的水滴溢出，被丢弃。"),_("br"),t._v(" "),_("img",{attrs:{src:"https://images2015.cnblogs.com/blog/455275/201609/455275-20160913123140602-1054535618.png",alt:"漏桶算法"}})])]),t._v(" "),_("h2",{attrs:{id:"对比两个算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对比两个算法"}},[t._v("#")]),t._v(" 对比两个算法")]),t._v(" "),_("ul",[_("li",[t._v("令牌桶时按照固定速率往桶中添加令牌，请求是否被处理需要看桶里令牌是否足够，当令牌数是零时拒绝新的请求。")]),t._v(" "),_("li",[t._v("漏桶时按照常量固定速率流出请求，流入请求速率任意，当流入的请求数量累积到漏桶容量时，则新流入的请求被拒绝。")]),t._v(" "),_("li",[t._v("令牌桶限制的是单位时间内的平均流入速率，但是允许突发请求。")]),t._v(" "),_("li",[t._v("漏桶限制的是流出速度，也就是处理速度，碰到突发请求，也是按固定速率处理这些请求，平滑突发流入速率。"),_("br"),t._v("\n漏桶的简单实现：就是用到一个队列。队列的一端不断添加请求，另一端按照固定的速率，例如每秒1个，来从队列中读取请求处理。如果队列满了，可以选择一种策略来处理新来的请求，一是直接丢弃新请求，二是覆盖旧的请求。这个队列也可以改为用栈来实现，具体情况具体分析。")])]),t._v(" "),_("h2",{attrs:{id:"计数器限流"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#计数器限流"}},[t._v("#")]),t._v(" 计数器限流")]),t._v(" "),_("p",[t._v("主要用来限制总并发数，对全局总请求数或者单位时间内的总请求数进行限流。这个方法比较简单。")]),t._v(" "),_("h2",{attrs:{id:"应用级限流"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#应用级限流"}},[t._v("#")]),t._v(" 应用级限流")]),t._v(" "),_("ul",[_("li",[t._v("限制总并发/连接/请求数。例如Tomcat、Nginx、Redis可以对线程数、连接数做限制。")]),t._v(" "),_("li",[t._v("限制总资源数。如果有的资源是稀缺资源，而且可能有多个系统都会是用它，那么需要限制应用。最常用的池化技术，线程池或者连接池。")]),t._v(" "),_("li",[t._v("限流某个接口的总并发/请求数。在Java中可以用AtomicLong进行计数限制。")]),t._v(" "),_("li",[t._v("限流某个接口的时间窗请求数。这和上面的相似，可以用一个计数器进行限制。")]),t._v(" "),_("li",[t._v("平滑限流某个接口的请求数。上面的两种方法都不能很好的应对突发请求，但有时候会需要对突发请求做一些平滑整形。这时候可以用令牌桶或者漏桶算法。")])]),t._v(" "),_("h2",{attrs:{id:"分布式限流"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分布式限流"}},[t._v("#")]),t._v(" 分布式限流")]),t._v(" "),_("p",[t._v("分布式限流最关键的是将限流服务做成原子化，而解决方案可以是用redis+lua或者nginx+lua。")]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[t._v('    local key = KEYS[1] --限流KEY（一秒一个）  \nlocal limit = tonumber(ARGV[1])        --限流大小  \nlocal current = tonumber(redis.call(\'get\', key) or "0")  \nif current + 1 > limit then --如果超出限流大小  \n   return 0  \nelse if current == 1 then --设置2秒过期  \n    redis.call("INCRBY", key, "1")  \n    redis.call("EXPIRE", key, "2")  \nelse  --请求数+1  \n   redis.call("INCRBY", key,"1")  \n   return 1  \nend  ')])])])])}),[],!1,null,null,null);v.default=a.exports}}]);